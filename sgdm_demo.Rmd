---
title: "sgdm: an R package for performing sparse generalized dissimilarity modeling including tools for gdm"
author: "Jacob Nesslage (Modified from a vignette on sgdm by Pedro J. LeitÃ£o, Marcel Schwieder, and Cornelius Senf)"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sgdm-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Installing `sgdm`

In order to install `sgdm` from GitHub, you need to install the `devtools` package first. Using the `install_git` function in the `devtools` package, the `sgdm` package can be easily installed:

```{r, eval=FALSE}
library(devtools)
devtools::install_github("sparsegdm/sgdm_package")

library(sgdm)
```

```{r, echo=FALSE}
library(sgdm)
library(gdm)
```

**Note 1:** On a Linux (Ubuntu) machine things might be a little more complicated and you first need to install openssl for linux:

- sudo apt-get install libcurl4-openssl-dev libxml2-dev
- sudo apt-get install libssl-dev

Before you can install the `devtools` package.

**Note 2:** The `PMA` package, which is required by SGDDM and installed automatically, needs the `impute` package from the bioclite repository. However, it seems that `PMA` doe not automatically load `impute`. If you haven't installed either `PMA` or `impute` before, you need to first install the `impute` package:

```{r, echo=FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite("impute")
```

## Exemplary data

The package includes nine functions, and three exemplary datasets. The exemplary datasets include one biological dataset, one predictor dataset and one predictor map. The trees biological dataset is composed of 30 observations with abundance values for 48 different tree families in an area of natural vegetation in the Brazilian Cerrado. The spectra predictor dataset is composed of the same 30 observations, with reflectance values for 83 narrow spectral bands; extracted from spaceborne hyperspectral Hyperion imagery after pre-processing and band quality screening. Both datasets include an ID column and the later also include two geographical coordinate (X and Y) columns. The spectral.image predictor map is a raster object constituting of a subset (100 times 100 pixels) of the respective Hyperion image.

## Running a `sgdm` model

Running a full `sgdm` model requires five steps:

- Parameterize and train the SGDM model
- Reduce the SGDM model by identifying non-significant predictors
- Validate the SGDM model
- Map community composition patterns

In the following we will go through each of the four steps in order to examplify how the `sgdm` package works.

### Parameterize and train the SGDM model

First, we want to load our community data and our predictor data into memory, mainly so we can visualize what the format is for these datasets.

```{r load data}
spectra = spectra
trees = trees
```


```{r fixes for buggy functions in sgdm}
#From getFromNamespace("sgdm.param","sgdm")
sgdm.param <- function (predData, bioData, k = 10, predPenalization = seq(0.6, 
  1, 0.1), bioPenalization = seq(0.6, 1, 0.1), geo = F) 
{
  cat("\n")
  cat("Running SGDM model paramerization\n")
  cat("\n")
  j1 <- ncol(predData)
  j2 <- ncol(bioData)
  n2 <- nrow(bioData)
  t2 <- n2 - 1
  pairc <- n2 * t2
  latlong <- as.matrix(predData[, 2:3])
  id <- as.matrix(predData[, 1])
  r <- as.matrix(bioData[, 2:j2])
  p <- as.matrix(predData[, 4:j1])
  br <- length(bioPenalization)
  bc <- length(predPenalization)
  perf.matrix <- matrix(ncol = bc, nrow = br, data = 0)
  rownames(perf.matrix) = bioPenalization
  colnames(perf.matrix) = predPenalization
  cat("Grid search for setting SCCA penalization:\n")
  for (px in bioPenalization) for (pz in predPenalization) {
    cat("\n")
    cat(paste("Penalization on biological data (x) =", px, 
      "; penalization on predcitor data (y) =", pz, "\n"))
    cat("\n")
    cat("SCCA Model:\n")
    cca <- PMA::CCA(r, p, typex = "standard", typez = "standard", 
      penaltyx = px, penaltyz = pz, K = k, niter = 50, 
      v = NULL, trace = TRUE, standardize = TRUE, xnames = NULL, 
      znames = NULL)
    v <- cca$v
    c <- p %*% v
    cgi <- cbind(id, latlong, c)
    cgi <- as.data.frame(cgi)
    colnames(cgi)[1] <- "Plot_ID"
    spData <- gdm::formatsitepair(bioData, 1, dist = "bray", 
      abundance = TRUE, siteColumn = "Plot_ID", XColumn = "X", 
      YColumn = "Y", predData = cgi)
    result <- gdm.cv(spData, nfolds = 5, geo = geo)
    perf.matrix[paste(px), paste(pz)] <- result[1]
  }
  cat("\n")
  cat("\n")
  cat("Finished SGDM parameterization: performance raster created\n")
  cat("\n")
  return(perf.matrix)
}

gdm.cv <- function (spData, nfolds = 10, performance = "rmse", geo = F) 
{
  cat("\n")
  cat("GDM model cross-validation\n")
  cat("\n")
  pairs <- nrow(spData)
  n2 <- (1 + sqrt(1 + 8 * pairs))/2
  t2 <- n2 - 1
  pairc <- n2 * t2
  if (nfolds > n2) {
    cat("\n")
    cat("ERROR: Incorrect number of folds for GDM cross-validation\n")
    cat("\n")
  }
  else {
    if (nfolds == n2) {
      cat("Performing leave-one-out cross-validation")
      cat("\n")
      cat("\n")
      perf.test <- matrix(ncol = 2, nrow = pairc, data = 0)
      colnames(perf.test) = c("observed", "predicted")
      a <- 1
      s2 <- t2
      for (h in 1:n2) {
        cat(paste("Held-out sample", h, "of", n2, "\n"))
        index <- as.data.frame(matrix(ncol = n2, nrow = n2, 
          data = 1))
        index[h, ] <- 0
        index[, h] <- 0
        indexd <- as.dist(index)
        index.sel <- as.data.frame(matrix(ncol = 1, 
          nrow = pairs, data = 0))
        o <- 1
        q <- 1
        for (p in 2:n2) {
          for (i in p:n2) {
            index.sel[q, 1] <- indexd[q]
            q <- q + 1
          }
          o <- o + 1
        }
        caldata <- spData[which(index.sel == 1), ]
        valdata <- spData[which(index.sel == 0), ]
        observed <- as.data.frame(valdata[, 1])
        partial.gdm <- gdm::gdm(caldata, geo = geo)
        predicted <- predict(partial.gdm, valdata)
        predicted <- as.data.frame(predicted)
        perf.test[a:s2, 1] <- observed[1:t2, 1]
        perf.test[a:s2, 2] <- predicted[1:t2, 1]
        a <- a + t2
        s2 <- s2 + t2
      }
    }
    if (nfolds < n2) {
      cat(paste("Performing ", nfolds, "-fold cross-validation", 
        sep = ""))
      cat("\n")
      cat("\n")
      perf.test <- matrix(ncol = 2, nrow = nfolds, data = 0)
      colnames(perf.test) = c("observed", "predicted")
      selector <- rep(seq(1, nfolds, by = 1), length = n2)
      selector <- selector[order(runif(n2, 1, 100))]
      a <- 1
      for (h in 1:nfolds) {
        cat(paste("Fold", h, "of", nfolds, "\n"))
        index <- as.data.frame(matrix(ncol = n2, nrow = n2, 
          data = 1))
        index[selector == h, ] <- 0
        index[, selector == h] <- 0
        indexd <- as.dist(index)
        index.sel <- as.data.frame(matrix(ncol = 1, 
          nrow = pairs, data = 0))
        o <- 1
        q <- 1
        for (p in 2:n2) {
          for (i in p:n2) {
            index.sel[q, 1] <- indexd[q]
            q <- q + 1
          }
          o <- o + 1
        }
        caldata <- spData[which(index.sel == 1), ]
        valdata <- spData[which(index.sel == 0), ]
        observed <- as.data.frame(valdata[, 1])
        partial.gdm <- gdm::gdm(caldata, geo = geo)
        predicted <- predict(partial.gdm, valdata)
        predicted <- as.data.frame(predicted)
        t3 <- nrow(valdata)
        s2 <- t3
        if (h == 1) {
          perf.test <- cbind(observed, predicted)
          colnames(perf.test) = c("observed", "predicted")
        }
        else {
          temp <- cbind(observed, predicted)
          colnames(temp) <- colnames(perf.test)
          perf.test <- rbind(perf.test, temp)
        }
        a <- a + t3
        s2 <- s2 + t3
      }
    }
    if (performance == "r2") {
      cat("\n")
      cat("Calculating model R-square (R2)...\n")
      cat("\n")
      performance <- (cor(perf.test[, 1], perf.test[, 
        2])^2) * 100
    }
    if (performance == "rmse") {
      cat("\n")
      cat("Calculating model Root Mean Square Error (RMSE)...\n")
      cat("\n")
      performance <- sqrt(mean((perf.test[, 1] - perf.test[, 
        2])^2))
    }
    cat("Model performance calculated\n")
    cat("\n")
    return(performance)
  }
}
```


For parameterizing a `sgdm` model, it is necessary to identify the best penalization parameter pair using a heuristic grid search implemented in the function `sgdm.param`:

```{r, results='hide'}

sgdm.gs <- sgdm.param(predData = spectra, bioData = trees, k = 30, 
                      predPenalization = seq(0.6, 1, 0.1), bioPenalization = seq(0.6, 1, 0.1), geo = F)
```

```{r}
spData <- gdm::formatsitepair(trees, 1, dist = "bray", 
      abundance = TRUE, siteColumn = "Plot_ID", XColumn = "X", 
      YColumn = "Y", predData = cgi)
    result <- gdm.cv(spData, nfolds = 5, geo = geo)
```

The parameter `k` sets the number of components to be used and the parameters `predPenalization` and `bioPenalization` set the penalization values to be tested (ranging from 0 (strong penalization) to 1 (weak penalization). The standard values implemented in this function range from 0.6 to 1 in 0.1 steps, but these values can be manually configured to better match the used datasets. Finally, the user can specify if geographical distance as a variable in the GDM model should be used. Note that this function implementation only allows biological data in **format 1** specification as described in the `gdm` package.

The function `sgdm.param` returns a performance matrix, with the performance values (RMSE) of each parameter pair estimated from 5-fold cross-validation:

```{r}
print(sgdm.gs, digits = 4)
```

Using the performance matrix and the `sgdm.best` function, we can retreive the best model (`output = "m"`):

```{r, results='hide'}
sgdm.model <- sgdm.best(perf.matrix = sgdm.gs, predData = spectra, bioData = trees, output = "m", k = 30)
```

Summary of the model:

```{r, results='hide'}
summary(sgdm.model)
```

Alternatively, the sgdm.best function also allows the user to retrieve the resulting sparse canonical components (`output = "c"`) or the respective canonical vectors (`output = "v"`).

```{r, results='hide'}
sgdm.sccbest <- sgdm.best(perf.matrix = sgdm.gs, predData = spectra, bioData = trees, output = "c", k = 30)
sgdm.vbest <- sgdm.best(perf.matrix = sgdm.gs, predData = spectra, bioData = trees, output = "v", k = 30)
```

### Reduce the SGDM model by removing non-significant predictors

Some of the sparse canonical components might be less important than others. In order to reduce the model complexity, we can utilize the `gdm.varsig` function with the sparse canonical components and the biological data:

```{r, results='hide'}
sigtest.sgdm <- gdm.varsig(predData = sgdm.sccbest, bioData = trees) #To reduce number of CCA components
```

and use this significance test result to reduce the predictor data for re-training the model:

```{r}
sgdm.sccbest.red <- data.reduce(data = sgdm.sccbest, datatype = "pred", sigtest = sigtest.sgdm)
```

In order to train the final model, the significant sparse canonical components must be combined with the biological dataset in a site pair dataset using the function `formatsitepair` in the `gdm` package:

```{r}
spData.sccabest.red <- gdm::formatsitepair(bioData = trees, bioFormat = 1, dist = "bray",
                                           abundance = TRUE, siteColumn = "Plot_ID", 
                                           XColumn = "X",YColumn = "Y", predData = sgdm.sccbest.red)

sgdm.model.red <- gdm::gdm(data = spData.sccabest.red)
```

The final model can now be inspected and the predicted dissimilarities plotted:

```{r, results='hide'}
summary(sgdm.model.red)
```

```{r}
plot(sgdm.model.red$predicted, sgdm.model.red$observed, xlim = c(0, 1), ylim = c(0, 1))
abline(0, 1)
```

### Validate the SGDM model

For independent validation, there is a function in the `sgdm` package called `gdm.cv`, which performes n-fold cross-validation on a (S)GDM model:

```{r}
gdm.cv(spData = spData.sccabest.red, nfolds = 10)
```

The functions returns the cross-validated RMSE value (default). Alternatively, the cross-validated coefficient of determination (r$^2$) can be returned:

```{r}
gdm.cv(spData = spData.sccabest.red, nfolds = 10, performance = "r2")
```

### Map community composition patterns

The community composition patterns can be plotted along the main axes of variation following an NMDS transformation of the predicted dissimilarities between sample pairs. Before this can occur, we have to implement a couple of bug fixes to the functions to enable them to work as intended.

```{r gdm.map() function fixes}
gdm.map <- function (spData, predMap, model, k = 0, t = 0.1) 
{
    if (!requireNamespace("raster", quietly = TRUE)) {
        stop("raster package needed for this function to work. Please install it.", 
            call. = FALSE)
    }
    if (!requireNamespace("yaImpute", quietly = TRUE)) {
        stop("yaImpute package needed for this function to work. Please install it.", 
            call. = FALSE)
    }
    pairs <- nrow(spData)
    n2 <- (1 + sqrt(1 + 8 * pairs))/2
    nVars <- (ncol(spData) - 6)/2
    dummy_ID <- data.frame(ID = 1:n2)
    first_sample <- cbind(dummy_ID[1, 1], spData[1, 3:4], spData[1, 
        7:(nVars + 6)])
    predData0 <- cbind(dummy_ID[2:n2, 1], spData[1:(n2 - 1), 
        5:6], spData[1:(n2 - 1), (nVars + 7):ncol(spData)])
    names <- c("ID", "X", "Y", paste0("Pred.", 1:(nVars)))
    colnames(first_sample) <- names
    colnames(predData0) <- names
    predData <- rbind(first_sample, predData0)
    cat("\n")
    cat("Performing GDM mapping\n")
    cat("\n")
    sample.pair <- spData
    sample.pair.diss <- predict(model, sample.pair) #changed from gdm.predict() to predict()
    X <- diag(x = 0, nrow(predData), nrow(predData))
    X[upper.tri(X, diag = FALSE)] <- sample.pair.diss
    X <- X + t(X) - diag(diag(X))
    sample.pair.diss.mat <- as.matrix(X)
    if (k == 0) {
        cat("\n")
        cat("Derive number of NMDS components based on stress values below", 
            t, "\n")
        cat("\n")
        stress <- matrix(nrow = 20, ncol = nrow(sample.pair.diss.mat))
        stress <- as.data.frame(stress)
        for (i in 1:nrow(sample.pair.diss.mat)) {
            for (j in 1:20) {
                table_nmds <- vegan::monoMDS(sample.pair.diss.mat, 
                  k = i, model = "global", maxit = 1000)
                stress[j, i] <- table_nmds$stress
            }
            cat("Mean stress value after 20 iterations with k =", 
                i, "is", apply(stress[i], 2, mean), "\n")
            cat("\n")
        }
        mean_stress <- as.matrix(apply(stress, 2, mean))
        k <- as.numeric(length(which(mean_stress > t)) + 1)
    }
    cat("\n")
    cat("Performing NMDS transformation on sample pair sites with", 
        k, "components\n")
    cat("\n")
    sample_nmds <- vegan::monoMDS(sample.pair.diss.mat, k = k, 
        model = "global", maxit = 1000)
    cat("\n")
    cat("NMDS stress value:", sample_nmds$stress)
    cat("\n")
    nmds_scores <- as.matrix(vegan::scores(sample_nmds))
    if (missing(predMap)) {
        return(nmds_scores)
    }
    else {
        data.type.check <- class(predMap)
        if (data.type.check == "RasterStack" || data.type.check == 
            "RasterBrick" || data.type.check == "RasterLayer") {
            cat("\n")
            cat("predMap, is data type", data.type.check, "and will be used to impute the NMDS-transformed GDM predicted dissimilarities\n")
            cat("\n")
            image.df <- raster::as.data.frame(predMap, xy = TRUE)
            image.df <- cbind(1:nrow(image.df), image.df)
            if (raster::nlayers(predMap) != nVars) 
                stop("Raster image must have same numbers of layers as numbers of predictors!")
            names(image.df) <- c("ID", "X", "Y", paste0("Pred.", 
                1:(nVars)))
            imputation.df <- cbind(nmds_scores, predData)
            rownames(imputation.df) <- paste0("I", 1:nrow(imputation.df))
            impute_model <- yaImpute::yai(x = imputation.df[, 
                (k + 4):ncol(imputation.df)], y = imputation.df[, 
                1:k], method = "euclidean")
            impute_model_image <- yaImpute::newtargets(impute_model, 
                image.df[, 4:ncol(image.df)])
            impute_image <- yaImpute::impute(impute_model_image)
            r_list <- vector("list", length = k)
            for (i in 1:k) {
                r <- raster::subset(predMap, 1)
                raster::values(r) <- impute_image[, i]
                names(r) <- names(impute_image)[i]
                r_list[[i]] <- r
            }
            impute_map <- raster::stack(r_list)
        }
    }
    return(impute_map)
}
```

Now we can plot the community composition patterns along the main axes of variation following an NMDS transformation of the predicted dissimilarities between sample pairs

```{r, results='hide'}
#BiocManager::install("yaImpute")
community.samples <- gdm.map(spData = spData.sccabest.red, model = sgdm.model.red, k = 0, t = 0.1)
```

The number of NMDS axes to be extracted is by default automatically determined by the resulting mean NMDS stress values out of 20 iterations following:

- less than 0.05: excellent
- less than 0.1: good
- greater 0.1: poor

The number of NMDS axes (`k`) can also be set by the user.

These patterns can also be mapped in space using a predictor map. As it would be unfeasible to run a NMDS on the dissimilarities between all possible pairs of image pixels, it is possible to assign the pixels to the NMDS axes from the sample pairs, through knn-imputation.

The predictor map used here is called `spectral.image` and is a `RasterStack` object, which can be plotted in false color:

```{r}
raster::plotRGB(spectral.image, r = 43, g = 22, b = 12, stretch = "hist")
```

In order to map the community composition patterns predicted by sgdm, it is necessary to apply the canonical transformation onto the prediction map. The resulting component map must also to be reduced according to the variable significance test:

```{r}
component.image <- predData.transform(predData = spectral.image, v = sgdm.vbest) #30 bands
component.image.red <- data.reduce(component.image, datatype = "pred", sigtest = sigtest.sgdm) #7 bands
```

With the resulting reduced component image, it is possible to map the community composition patterns in space. For example, in order to visualize them in RGB space, it is possible to extract 3 NMDS axes:

```{r}
map.sgdm.red <- gdm.map(spData = spData.sccabest.red, predMap = component.image.red, model = sgdm.model.red, k = 3)
raster::plotRGB(map.sgdm.red, r = 3, g = 2, b = 1, stretch = "hist")
```

